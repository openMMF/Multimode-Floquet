SUBROUTINE REC_WRITE_MATRIX_C(A,A_dim1,A_dim2)
  ! it writes a matrix of doubles nxm on the screen
  USE SUBINTERFACE_LAPACK
  INTEGER, INTENT(IN) :: A_dim1,A_dim2  
  DOUBLE PRECISION, DIMENSION(A_dim1*A_dim2),intent(in) :: A 


  INTEGER I,J
  DOUBLE PRECISION, DIMENSION(A_dim1,A_dim2) :: A_FORTRAN

  write(*,*) 'fortan says: ',A_DIM


  DO I=1,A_DIM1
     DO J = 1,A_DIM2
        A_FORTRAN(I,J) = A(I+(J-1)*A_DIM1)
     END DO
  END DO


  CALL WRITE_MATRIX(A_FORTRAN)  

END SUBROUTINE REC_WRITE_MATRIX_C

SUBROUTINE WRITE_MATRIX_C(A,A_dim)
  ! it writes a matrix of doubles nxm on the screen
  USE SUBINTERFACE_LAPACK
  INTEGER, INTENT(IN) :: A_dim  
  DOUBLE PRECISION, DIMENSION(A_dim*A_dim),intent(in) :: A 


  INTEGER I,J
  DOUBLE PRECISION, DIMENSION(A_dim,A_dim) :: A_FORTRAN

  !write(*,*) 'fortan says: ',A_DIM


  DO I=1,A_DIM
     DO J = 1,A_DIM
        A_FORTRAN(I,J) = A(I+(J-1)*A_DIM)
     END DO
  END DO


  CALL WRITE_MATRIX(A_FORTRAN)  

END SUBROUTINE WRITE_MATRIX_C

SUBROUTINE WRITE_MATRIX_INT_C(A,A_dim)
  !it writes a matrix of integer nxm on the screen
  USE SUBINTERFACE_LAPACK
  INTEGER, INTENT(IN) :: A_dim
  DOUBLE PRECISION, DIMENSION(A_dim),intent(in) :: A 

  INTEGER I,J
  INTEGER, DIMENSION(A_dim,A_dim) :: A_FORTRAN



  DO I=1,A_DIM
     DO J = 1,A_DIM
        A_FORTRAN(I,J) = A(I+(J-1)*A_DIM)
     END DO
  END DO

  CALL WRITE_MATRIX_INT(A_FORTRAN)  
END SUBROUTINE WRITE_MATRIX_INT_C


SUBROUTINE COORDINATEPACKING_C(D,A,V,R,C,index,INFO)
  IMPLICIT NONE
  INTEGER,INTENT(IN):: D
  COMPLEX*16,DIMENSION(D,D),INTENT(IN)  :: A
  COMPLEX*16,DIMENSION(D*D),INTENT(OUT) :: V
  INTEGER, DIMENSION(D*D),  INTENT(OUT) :: R,C
  INTEGER, INTENT(OUT)   :: index
  INTEGER, INTENT(INOUT) :: INFO

  CALL COORDINATEPACKING(D,A,V,R,C,index,INFO)

END SUBROUTINE COORDINATEPACKING_C

MODULE MERGINGARRAYS_C
  INTERFACE
     SUBROUTINE APPENDARRAYS_C(V,B,INFO)
       COMPLEX*16, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) :: V
       COMPLEX*16, DIMENSION(:),INTENT(IN)    :: B
       INTEGER,                 INTENT(INOUT) :: INFO
     END SUBROUTINE APPENDARRAYS_C
     SUBROUTINE APPENDARRAYSI_C(V,B,INFO)
       INTEGER, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) :: V
       INTEGER, DIMENSION(:),INTENT(IN)    :: B
       INTEGER,                 INTENT(INOUT) :: INFO
     END SUBROUTINE APPENDARRAYSI_C
  END INTERFACE
END MODULE MERGINGARRAYS_C

SUBROUTINE APPENDARRAYS_C(V,B,INFO)
  COMPLEX*16, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) :: V
  COMPLEX*16, DIMENSION(:),INTENT(IN)    :: B
  INTEGER,                 INTENT(INOUT) :: INFO

  CALL APPENDARRAYS(V,B,INFO)

END SUBROUTINE APPENDARRAYS_C

SUBROUTINE APPENDARRAYSI_C(V,B,INFO)
  INTEGER, DIMENSION(:),ALLOCATABLE, INTENT(INOUT) :: V
  INTEGER, DIMENSION(:),INTENT(IN)    :: B
  INTEGER,                 INTENT(INOUT) :: INFO

  COMPLEX*16,DIMENSION(:),ALLOCATABLE :: tmp_arr

  CALL APPENDARRAYSI(V,B,INFO)

END SUBROUTINE APPENDARRAYSI_C

!SUBROUTINE MATMUL_C(OP_LENGHT,OP,A,RA,CA,B,RB,CB,C,INFO)
SUBROUTINE MATMUL_C(OP,A,RA,CA,B,RB,CB,C,INFO)

  IMPLICIT NONE
  !INTEGER, INTENT(IN):: RA,CA,RB,CB,OP_LENGHT
  !CHARACTER(OP_LENGHT), INTENT(IN) :: OP
  INTEGER, INTENT(IN):: RA,CA,RB,CB,OP

  COMPLEX*16, DIMENSION(RA,CA), INTENT(IN)::A
  COMPLEX*16, DIMENSION(RB,CB), INTENT(IN)::B
  COMPLEX*16, DIMENSION(RA,CB), INTENT(INOUT)::C
  INTEGER, INTENT(INOUT):: INFO

  !write(*,*) abs(A)**2
  !write(*,*) abs(B)**2
  !write(*,*) op
  SELECT CASE (OP)
     
     !CASE("T")
  CASE(1)
     IF(RA.EQ.RB) THEN
        C = MATMUL(TRANSPOSE(A),B)
     ELSE
        C = 0.0
        INFO = -1
        WRITE(*,*) 'ERROR, INCONSISTENCY WITH THE DIMENSIONS OF THE MATRICES'
     END IF


  !CASE("TC")
  CASE(2)
     
     !WRITE(*,*) "TC"
     IF(RA.EQ.RB) THEN
        C = MATMUL(TRANSPOSE(CONJG(A)),B)
     ELSE
        C = 0.0
        INFO = -1
        WRITE(*,*) 'ERROR, INCONSISTENCY WITH THE DIMENSIONS OF THE MATRICES'
     END IF

  !CASE("C")
  CASE(3)

     IF(CA.EQ.RB) THEN
        C = MATMUL(CONJG(A),B)
     ELSE
        C = 0.0
        INFO = -1
        WRITE(*,*) 'ERROR, INCONSISTENCY WITH THE DIMENSIONS OF THE MATRICES'
     END IF

  !CASE("N")
  CASE(4)

     !WRITE(*,*) "N"
     !write(*,*) abs(A)**2
     IF(CA.EQ.RB) THEN
        !write(*,*) abs(A)**2
        C = MATMUL(A,B)
        !write(*,*) abs(C)**2
     ELSE
        C = 0.0
        INFO = -1
        WRITE(*,*) 'ERROR, INCONSISTENCY WITH THE DIMENSIONS OF THE MATRICES'
     END IF

  CASE default
     !               WRITE(*,*) "DEFAULT"
     IF(CA.EQ.RB) THEN
        C = MATMUL(A,B)
     ELSE
        C = 0.0
        INFO = -1
        WRITE(*,*) 'ERROR, INCONSISTENCY WITH THE DIMENSIONS OF THE MATRICES'
     END IF
  END SELECT

END SUBROUTINE MATMUL_C
